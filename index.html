<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Bigilla&family=Cormorant+Garamond:wght@400;500;600;700&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet" />
   
    <!-- Favicon links -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.jpg" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.jpg" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.jpg" />
    <link rel="manifest" href="/manifest.json" />
   
    <title>Habtam Limited - Premium Kenyan Tea Exports</title>
    <link rel="canonical" href="https://habtamltd.com/" />
    <meta name="description" content="Habtam Ltd specializes in sourcing and exporting premium quality tea from Kenya. We provide complete buyer, importer, and exporter services with guaranteed quality and efficient delivery." />
    <meta name="author" content="Habtam Limited" />
    <meta property="og:title" content="Habtam Limited - Premium Kenyan Tea Exports" />
    <meta property="og:description" content="Sourcing the finest quality tea from Kenya's highlands, delivering excellence to importers worldwide" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />
   
    <!-- Schema.org JSON-LD -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "Habtam Limited",
      "url": "https://www.habtamltd.com",
      "logo": "https://www.habtamltd.com/logo.png",
      "description": "Premium quality tea exporter from Kenya, specializing in sourcing and supplying finest grade tea to importers worldwide",
      "address": {
        "@type": "PostalAddress",
        "addressCountry": "KE"
      },
      "contactPoint": {
        "@type": "ContactPoint",
        "contactType": "Business Inquiries",
        "email": "info@habtamltd.com"
      }
    }
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <script>
    /**
 * COMPREHENSIVE LOVABLE BADGE REMOVER - JAVASCRIPT
 * Add this script to your HTML file, preferably at the end of <body>
 * This handles dynamically loaded badges that CSS can't catch
 */

(function() {
  'use strict';

  // Function to remove badge elements
  function removeLovableBadge() {
    // Remove by ID
    const idSelectors = [
      '#lovable-badge',
      '#lovable-badge-root',
      '#lovable-branding',
      '#powered-by-lovable',
      '[id*="lovable"]',
      '[id*="badge"]'
    ];

    idSelectors.forEach(selector => {
      try {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          el.remove();
        });
      } catch (e) {}
    });

    // Remove by class
    const classSelectors = [
      '.lovable-badge',
      '.lovable-branding',
      '.powered-by-lovable',
      '[class*="lovable-badge"]',
      '[class*="lovable-branding"]'
    ];

    classSelectors.forEach(selector => {
      try {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          el.remove();
        });
      } catch (e) {}
    });

    // Remove links to lovable.dev
    const lovableLinks = document.querySelectorAll('a[href*="lovable.dev"], a[href*="lovable.com"], a[href*="lovable.app"]');
    lovableLinks.forEach(link => {
      // Remove the link
      link.remove();
      
      // Also remove parent if it only contained the link
      if (link.parentElement && link.parentElement.children.length === 0) {
        link.parentElement.remove();
      }
    });

    // Remove elements with lovable-related data attributes
    const dataElements = document.querySelectorAll('[data-lovable], [data-lovable-badge], [data-badge*="lovable"]');
    dataElements.forEach(el => {
      el.remove();
    });

    // Remove fixed position elements in corners that might be badges
    const fixedElements = document.querySelectorAll('div[style*="position: fixed"], div[style*="position:fixed"]');
    fixedElements.forEach(el => {
      const style = window.getComputedStyle(el);
      const isFixed = style.position === 'fixed';
      const hasHighZIndex = parseInt(style.zIndex) > 9990;
      const isInCorner = (style.bottom !== 'auto' || style.top !== 'auto') && 
                         (style.right !== 'auto' || style.left !== 'auto');
      const isSmall = el.offsetHeight < 100 && el.offsetWidth < 200;
      
      if (isFixed && hasHighZIndex && isInCorner && isSmall) {
        const hasLovableLink = el.querySelector('a[href*="lovable"]');
        if (hasLovableLink) {
          el.remove();
        }
      }
    });

    // Remove iframes that might contain the badge
    const iframes = document.querySelectorAll('iframe[src*="lovable"], iframe[id*="lovable"]');
    iframes.forEach(iframe => {
      iframe.remove();
    });

    // Check shadow DOM elements
    const allElements = document.querySelectorAll('*');
    allElements.forEach(el => {
      if (el.shadowRoot) {
        const shadowBadges = el.shadowRoot.querySelectorAll('[id*="lovable"], [class*="lovable"], a[href*="lovable"]');
        shadowBadges.forEach(badge => {
          badge.remove();
        });
      }
    });
  }

  // Run immediately when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', removeLovableBadge);
  } else {
    removeLovableBadge();
  }

  // Run after page fully loads (catches late-loading elements)
  window.addEventListener('load', function() {
    removeLovableBadge();
    
    // Continue checking for 5 seconds after load (some badges load very late)
    setTimeout(removeLovableBadge, 100);
    setTimeout(removeLovableBadge, 500);
    setTimeout(removeLovableBadge, 1000);
    setTimeout(removeLovableBadge, 2000);
    setTimeout(removeLovableBadge, 5000);
  });

  // Set up a MutationObserver to catch dynamically added badges
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.addedNodes.length) {
        // Check if any added node is a badge or contains a badge
        mutation.addedNodes.forEach(function(node) {
          if (node.nodeType === 1) { // Element node
            // Check if the node itself is a badge
            if (node.id && node.id.includes('lovable')) {
              node.remove();
            }
            if (node.className && typeof node.className === 'string' && node.className.includes('lovable')) {
              node.remove();
            }
            // Check if node contains lovable links
            if (node.querySelector) {
              const lovableLinks = node.querySelectorAll('a[href*="lovable"]');
              lovableLinks.forEach(link => link.remove());
            }
          }
        });
        // Run full cleanup
        removeLovableBadge();
      }
    });
  });

  // Start observing the document with the configured parameters
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });

  // Also run cleanup on any dynamic route changes (for SPAs)
  let lastUrl = location.href;
  new MutationObserver(function() {
    const url = location.href;
    if (url !== lastUrl) {
      lastUrl = url;
      setTimeout(removeLovableBadge, 100);
    }
  }).observe(document, { subtree: true, childList: true });

  console.log('Lovable badge remover initialized');
})();
</script>        
  </body>
</html>
